## let 命令

* 只要块级作用域内存在 ```let``` 命令，它所声明的变量就 "绑定"（binding）这个区域，不再受外部的影响。

* ```typeof``` 不再是一个百分比安全的操作（如果一个变量根本没有被声明，使用 ```typeof``` 反而不会报错）

* ```function bar(x = y, y = 2) {}``` （```y``` 没有声明，所以会报错）

* 不允许重复声明

* 块级作用域的出现，使得立即执行函数表达式（IIFE）不再必要了

* 建议避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

* 允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错

* 在 ES6 浏览器中（只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 ```let``` 处理）

 * 允许在块级作用域内声明函数

 * 函数声明类似于 ```var```，即会提升到全局作用域或函数作用域的头部

 * 同时，函数声明还会提升到所在的块级作用域的头部

```js
// 不报错
"use strict";
if (true) {
    function f() { }
}

// 报错
"use strict";
if (true)
    function f() { }
```




## const 命令

* 声明一个只读常量，一旦声明，常量的值就不能改变，而且必须立即初始化，不能留到以后在赋值

* ```const foo = {};```

 * 常量 ```foo``` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 ```foo``` 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

* 与 ```let``` 命令相似之处：

 * 只能在声明所在的块级作用域内有效

 * 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用

 * 不可重复声明



## 字符串的扩展

* 添加了遍历器接口，使得字符串可以被 ```for...of``` 循环遍历

* 添加了三个用于查询字符串位置的函数：

 * ```includes()```： 返回布尔值，表示是否找到了参数字符串

 * ```startsWith()```： 返回布尔值，表示参数字符串是否在源字符串的头部

 * ```endsWith()```： 返回布尔值，表示参数字符串是否在源字符串的尾部

以上三个方法都支持第二个参数，表示开始搜索的位置，不同之处在于 ```endsWith``` 针对前 ```n``` 个字符，而其他两个方法针对从第 ```n``` 个位置直到字符串结束。

* ```repeat()``` 方法返回一个新字符串，表示将原字符串重复 ```n``` 次

 * 如果是小数，则会被取整（*2 => 2, *9 => 2）

 * 如果是负数（小于-1）或者 ```Infinity```，则会报错

 * 如果是 ```0``` 到 ```-1``` 之间的小数，则等同于 ```0```，因为会先进行取整运算（NaN 也等同于 0）

 * 如果参数是字符串，则会先转换为数字（"3" => 3, "na" => ""）

* 新增了模版字符串

```js
$("#result").append(`
    There are <b> ${basket.count} </b> items
    in your basket, <em> ${basket.onSale} </em>
    are on sale!
`);
```

 * 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义（`\`Hello\` World!`）

 * 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。

 * 如果想去掉模版字符串开头和结尾处的换行，可以使用 ```trim``` 方法消除它。

 * 如果大括号内部是一个字符串，将会原样输出（`Hello ${"World}` => "Hello World"）

 * 模板字符串中也可以嵌入变量以及调用函数，比如 ```${user.name}```，```${fn()}```




## 对象的扩展

* 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = "bar";
var baz = {foo};
baz;  // {foo: "bar"}
```

* 方法也可以简写 ```method () {return "hello"}```

* 可以用于函数的返回值：

```js
function getPoint () {
    var x = 1;
    var y = 2;
    return {x, y};
}

getPoint();  // {x: 1, y: 2}
```

* 新增属性名表达式 ```obj["a" + "bc"] = 123;```

 * 表达式也可以用于定义方法名

* 属性名表达式与简洁表示法，不能同时使用，否则会报错

* 特别注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 ```[object, Object]```

```js
const myObject = {
    [keyA]: "valueA",
    [keyB]: "valueB"
};

// [keyB] 会把 [keyA] 覆盖掉，而 myObject 最后只有一个 [object Object] 属性
```



## 数值的扩展

* ```parseInt()``` 和 ```parseFloat()``` 移植到了 ```Number``` 对象上面 （```Number.parseInt("1*34")  // 12```）

* ```Number.isInteger()``` 用来判断一个值是否为整数（在 JavaScript 内部，整数和浮点数是同样的储存方法，所以 ```3``` 和 ```3.0``` 被视为同一个值）

Math 对象扩展：

* ```Math.trunc()``` 方法用于去除一个数的小数部分，返回整数部分

 * 对于非数值，内部会先使用 ```Number``` 方法将其先转为数值

 * 对于空值和无法截取整数的值，返回 ```NaN```

* ```Math.sign()``` 方法用来判断一个数到底是正数，负数，还是零，会返回五种值：

 * 参数为正数，返回 ```+1```

 * 参数为负数，返回 ```-1```

 * 参数为 ```0```，返回 ```0```

 * 参数为 ```-0```，返回 ```-0```

 * 其他值，返回 ```NaN```

* ```Math.cbrt()``` 方法用于计算一个数的立方根

* ```Math.hypot()``` 返回所有参数的 平方和 的 平方根 

```js 
Math.hypot(3, 4);  // 5（3 的平方 + 4 的平方 等于 5 的平方）
```




## 数组的扩展

* ```Array.from()``` 将 类似数组的对象（array-like-object） 和 可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）转为 **真正的数组**

 * 接受的第二个参数，作用类似于数组的 ```map``` 方法，用来对每个元素进行处理，将处理后的结果放入返回的数组

 * 如果 ```Array.from()``` 没有参数，就返回一个**空数组**

* ```Array.of()``` 用于将一组值，转换为数组（因为在 ES5 中，参数个数的不同，会导致 ```Array()``` 的行为有差异）

* ```find()``` 方法，用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 ```true``` 的成员，并返回，如果没有找到符合条件的成员，则返回 ```undefined```

 * 回调函数可以接受三个参数，依次为 当前的值、当前的位置 和 原数组

* ```findIndex()``` 方法的用法与 ```find()``` 方法非常相似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 ```-1```

 * ```find()``` 方法和 ```findIndex()``` 方法都可以发现 ```NaN```，弥补了数组的 ```indexOf``` 方法的不足

* ```fill()``` 方法使用给定值，填充一个数组

 * 需要注意的是，数组中已有的元素，会被全部抹去

 * 可以指定第二个和第三个参数，用于指定填充的起始位置和结束位置

* 提供了三个新的方法来用于遍历数组，它们都返回一个遍历器对象，可以用 ```for...of``` 循环进行遍历（如果不使用 ```for...of``` 循环，可以手动调用遍历器对象的 ```next()``` 方法，进行遍历）

 * ```keys()``` 是对**键名**的遍历

 * ```values()``` 是对**键值**的遍历

 * ```entries()``` 是对**键值对**的遍历

* ```Array.prototype.includes``` 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 ```includes``` 方法类似

 * 第二个参数表示搜索的起始位置，默认为 ```0```。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 ```-4```，但数组长度为 ```3```），则会重置为从 ```0``` 开始

```Map``` 和 ```Set``` 数据结构有一个 ```has``` 方法，需要注意与 ```includes``` 区分

* ```Map``` 结构的 ```has``` 方法，是用来查找**键名**的，比如 ```Map.prototype.has(key)```、```WeakMap.prototype.has(key)```、```Reflect.has(target, propertyKey)```

* ```Set``` 结构的 ```has``` 方法，是用来查找**值**的，比如 ```Set.prototype.has(value)```、```WeakSet.prototype.has(value)```





## 解构

```js
// 属于"模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值
var [a, b, c] = [1, 2, 3]
```

* 如果解构不成功，变量的值就等于 ```undefined```

* 如果等号右边不是数组（不是可遍历的解构，不具有 ```Iterator``` 接口），那么将会报错（number，string，false，NaN，undefined，null，{ } 等）

* 只要某种数据具有 ```Iterator``` 接口，都可以采用数组形式的解构赋值

* 解构赋值允许指定默认值（内部使用的是严格相等运算符 ```===```）

* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

* 对象的解构

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" }
```

* 对象的属性没有次序，变量必须与属性同名，才能取到正确的值

```js
let foo;
({ foo } = { foo: 1 }); // success

let baz;
({ bar: baz } = { bar: 1 }); // success
```

上例中的圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句




#### 字符串的解构

字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象



#### 数值和布尔值的解构

解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象

规则是，只要等号右边的值不是对象，就先将其转为对象，由于 ```undefined``` 和 ```null``` 无法转为对象，所以对它们进行解构赋值，都会报错



## 函数相关

* 在 ES6 中，允许函数的参数设置默认值，即直接写在参数定义的后面（函数参数的默认值）

 * 参数变量是默认声明的，所以不能使用 ```let``` 或者 ```const``` 再次声明

 * 指定了默认值以后，函数的 ```length``` 属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值以后，```length``` 属性将失效（length属性的含义是，该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了）

* 如果设置了默认值的参数不是尾参数（即设置默认值的不是最后一个参数），那么 ```length``` 属性也不再计入后面的参数了

* 如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域

* 用于将一个数组转为用都好分隔的参数序列（```console.log(...[1, 2, 3])```）

* 在 ES5 中，如果将一个匿名函数赋值给一个变量，其 ```name``` 属性，会返回空字符串，而 ES6 中修正了这个问题，会返回实际的函数名

 * ```Function``` 构造函数返回的函数实例，```name``` 属性的值为 ```anonymous```

 * ```bind``` 返回的函数，```name``` 属性会加上 ```bound``` 前缀

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 ```return``` 语句返回

```js
var sum = (num1, num2) => { return num1 + num2; }
```

* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号

```js
var getTempItem = id => ({ id: id, name: "Temp" });
```

* 箭头函数的使用注意点

 * 函数体内的 ```this``` 对象，就是定义时所在的对象，而不是使用时所在的对象（例如在 ```Vue``` 的实例属性或回调函数中就不建议使用箭头函数，因为箭头函数绑定父上下文，所以 ```this``` 不会像预想的一样是 Vue 实例，而是对应方法未被定义）

 * 不可以当作构造函数，也就是说，不可以使用 ```new``` 命令，否则会抛出一个错误

 * 不可以使用 ```arguments``` 对象，该对象在函数体内不存在。如果要用，可以用 ```Rest``` 参数代替

 * 不可以使用 ```yield``` 命令，因此箭头函数不能用作 ```Generator``` 函数

 * 需要特别注意的是：```this``` 对象的指向是可变的，但是在箭头函数中，它是固定的

 * 箭头函数中的 ```this``` 指向的固定化，并不是因为箭头函数内部有绑定 ```this``` 的机制，实际原因是箭头函数根本没有自己的 ```this```，导致内部的 ```this``` 就是外层代码块的 ```this```（正式因为它没有 ```this```，所以也就不能用作构造函数）



## Symbol

ES6 引入了一种新的原始数据类型 ```Symbol```，表示独一无二的值，它是 JavaScript 第七种数据类型

```js
// 变量 s 就是一个独一无二的值
let s = Symbol();

// typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型
typeof s
// "symbol"
```
